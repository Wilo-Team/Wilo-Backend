name: Deploy to Production Server (Mac Mini)

on:
  push:
    branches: ["main"]  # main 브랜치에 푸시될 때 운영 배포
  workflow_dispatch:  # 수동 실행 가능

permissions:
  contents: read

jobs:
  build-and-deploy-prod:
    runs-on: self-hosted  # Mac Mini의 Self-hosted Runner 사용

    steps:
      # 코드 체크아웃
      - name: Checkout code
        uses: actions/checkout@v4

      # JDK 21 설정 (캐시 완전 비활성화)
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
        env:
          SEGMENT_DOWNLOAD_TIMEOUT_MINS: 1  # 캐시 다운로드 타임아웃 1분으로 단축

      # application-prod.yml 생성
      - name: Create application-prod.yml
        run: |
          mkdir -p ./src/main/resources
          echo "${{ secrets.APPLICATION_PROD }}" > ./src/main/resources/application.yml
        shell: bash

      # Gradle 빌드 권한 부여
      - name: Grant execute permission for gradlew
        run: chmod +x gradlew
        shell: bash

      # Gradle 빌드 (테스트 제외)
      - name: Build with Gradle
        run: ./gradlew clean build -x test
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
        shell: bash

      # Docker 이미지 빌드 (PRODUCTION 태그)
      - name: Build Docker image
        run: |
          docker build -t ${{ secrets.DOCKER_USERNAME }}/wilo:prod-latest .
          docker tag ${{ secrets.DOCKER_USERNAME }}/wilo:prod-latest ${{ secrets.DOCKER_USERNAME }}/wilo:prod-${{ github.sha }}
        shell: bash

      # Docker Hub에 푸시
      - name: Push to Docker Hub
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
          docker push ${{ secrets.DOCKER_USERNAME }}/wilo:prod-latest
          docker push ${{ secrets.DOCKER_USERNAME }}/wilo:prod-${{ github.sha }}
        shell: bash

      # .env 파일 생성 (PRODUCTION)
      - name: Create .env file
        run: |
          cat > .env.prod << EOF
          DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}
          MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_ACCESS_EXP=${{ secrets.JWT_ACCESS_EXP }}
          JWT_REFRESH_EXP=${{ secrets.JWT_REFRESH_EXP }}
          JWT_ACCESS_TOKEN_SECRET=${{ secrets.JWT_ACCESS_TOKEN_SECRET }}
          JWT_ACCESS_TOKEN_EXPIRATION=1800000
          JWT_REFRESH_TOKEN_SECRET=${{ secrets.JWT_REFRESH_TOKEN_SECRET }}
          JWT_REFRESH_TOKEN_EXPIRATION=604800000
          SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }}
          EOF
        shell: bash

      # Blue-Green 무중단 배포
      - name: Blue-Green Deployment
        run: |
          # MySQL과 Redis 시작 (이미 실행 중이면 스킵)
          docker-compose -f docker-compose.prod.yml --env-file .env.prod up -d mysql-prod redis-prod

          # Orphan 컨테이너 정리 (기존 wilo-app-prod 등)
          echo "Cleaning up orphan containers..."
          docker stop wilo-app-prod 2>/dev/null || true
          docker rm wilo-app-prod 2>/dev/null || true
          docker stop wilo-app 2>/dev/null || true
          docker rm wilo-app 2>/dev/null || true

          # 현재 활성화된 환경 확인 (Blue가 실행 중이면 Green으로 배포, 그 반대도 동일)
          BLUE_RUNNING=$(docker ps --filter "name=wilo-app-prod-blue" --filter "status=running" -q)
          GREEN_RUNNING=$(docker ps --filter "name=wilo-app-prod-green" --filter "status=running" -q)

          if [ -n "$BLUE_RUNNING" ]; then
            # Blue가 실행 중이면 Green으로 배포
            CURRENT="blue"
            TARGET="green"
            CURRENT_PORT=8090
            TARGET_PORT=8091
          elif [ -n "$GREEN_RUNNING" ]; then
            # Green이 실행 중이면 Blue로 배포
            CURRENT="green"
            TARGET="blue"
            CURRENT_PORT=8091
            TARGET_PORT=8090
          else
            # 둘 다 실행 중이지 않으면 Blue로 초기 배포
            CURRENT="none"
            TARGET="blue"
            CURRENT_PORT=0
            TARGET_PORT=8090
          fi

          echo "Current active environment: $CURRENT (port $CURRENT_PORT)"
          echo "Deploying to target environment: $TARGET (port $TARGET_PORT)"

          # Target 환경에 새 버전 배포
          if [ "$TARGET" = "green" ]; then
            docker-compose -f docker-compose.prod.yml --env-file .env.prod --profile green up -d app-prod-green
          else
            docker-compose -f docker-compose.prod.yml --env-file .env.prod up -d app-prod-blue
          fi

          # 헬스체크 대기 (최대 2분)
          echo "Waiting for $TARGET environment to be healthy..."
          timeout=120
          elapsed=0
          healthy=false

          while [ $elapsed -lt $timeout ]; do
            HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' wilo-app-prod-$TARGET 2>/dev/null || echo "none")
            if [ "$HEALTH_STATUS" = "healthy" ]; then
              echo "$TARGET environment is healthy!"
              healthy=true
              break
            fi
            echo "Waiting... ($elapsed seconds) - Current status: $HEALTH_STATUS"
            sleep 5
            elapsed=$((elapsed + 5))
          done

          if [ "$healthy" = false ]; then
            echo "ERROR: $TARGET environment failed to become healthy within $timeout seconds"
            docker-compose -f docker-compose.prod.yml logs --tail=100 app-prod-$TARGET
            exit 1
          fi

          # Nginx 설정 업데이트 (Blue-Green 전환)
          echo "Switching Nginx to $TARGET environment (port $TARGET_PORT)..."
          sudo /opt/wilo/scripts/switch-nginx.sh $TARGET_PORT

          # Nginx 설정 테스트 및 재로드
          if sudo /opt/homebrew/bin/nginx -t; then
            sudo /opt/homebrew/bin/nginx -s reload
            echo "Nginx successfully switched to $TARGET environment"
          else
            echo "ERROR: Nginx configuration test failed"
            # 원래 환경으로 롤백
            sudo /opt/wilo/scripts/switch-nginx.sh $CURRENT_PORT
            exit 1
          fi

          # 10초 대기 후 이전 환경 종료 (안전을 위한 대기)
          echo "Waiting 10 seconds before stopping old environment..."
          sleep 10

          # 이전 환경 종료 (초기 배포가 아닌 경우만)
          if [ "$CURRENT" != "none" ]; then
            echo "Stopping old $CURRENT environment..."
            docker-compose -f docker-compose.prod.yml stop app-prod-$CURRENT || true
            docker-compose -f docker-compose.prod.yml rm -f app-prod-$CURRENT || true
          else
            echo "Initial deployment - no old environment to stop"
          fi

          # 컨테이너 상태 확인
          echo "=== Current Container Status ==="
          docker-compose -f docker-compose.prod.yml ps

          # 로그 출력 (마지막 50줄)
          echo "=== $TARGET Environment Logs ==="
          docker-compose -f docker-compose.prod.yml logs --tail=50 app-prod-$TARGET
        shell: bash

      # 12. 오래된 Docker 이미지 정리
      - name: Clean up old Docker images
        run: |
          docker image prune -f --filter "until=24h"
        shell: bash
        continue-on-error: true
